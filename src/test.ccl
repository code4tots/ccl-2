# comments!
x = 4
assert[-x == -4]
assert[1 != 2]
assert[1 + 1 == 2]
assert[true]
assert[1]
assert[not false]
assert[1 or 0]
assert[0 or 1]
assert[(0 or 1) == 1]
assert[(1 or 0) == 1]
assert[1 and 2]
assert[not (1 and 0)]
assert[(1 and 0) == 0]

def f[x] {
  return x + 2
}

assert[f[4] == 6]

assert[List[1,2,3].__str__[] == 'List[1, 2, 3]']

assert[String[List[1,2,3]] == 'List[1, 2, 3]']

assert[Bool[1] is true]
assert[Bool[0] is false]
assert[true is not false]

assert[1 != '1']
assert['1' != 1]

assert[new[Value] != new[Value]]

class MyClass {

  def my_method[arg] {
    return arg + 6
  }

  def no_return[] { 5 }
}

instance = new[MyClass]
assert[instance.my_method[5] == 11]
assert[instance.no_return[] == nil]

class A {
  def method[] { return 'method in A' }
}
class B {
  def method[] { return 'method in B' }
}
class C[A, B] {}

assert[new[C].method[] == 'method in A']

class A {
  def method[] { return 'method in A' }
}
class B[A] {}
class C[A] {
  def method[] { return 'method in C'}
}
class D[B, C] {}

# Tests that mro is not simple dfs
assert[new[D].method[] == 'method in C']

import import_test

assert[import_test@f[] == 'inside import_test']

# Test the self actually works

class A {
  def method1[] { return 'inside method 1' }
  def method2[] {
    assert[self.method1[] == 'inside method 1']
    return 'inside method 2'
  }
}

assert[new[A].method2[] == 'inside method 2']

## 'super' test.
class A {
  def method[] { return 'method in A' }
}
class B {
  def method[] { return 'method in B' }
}
class C[A, B] {
  def method[] { return super.method[] }
  def another_method[] { return super.method[] }
}

assert[new[C].method[] == 'method in A']
assert[new[C].another_method[] == 'method in A']

c = new[C]
c@x = 5
assert[c@x == 2 + 3]

assert[List[1, 2, 3] != List[2, 3, 4]]

f = \x. x * 3
g = \x y. x * y
assert[f[2] == 6]
assert[g[3, 2] == 6]

assert[List[1, 2, 3].map[\x. x + 1] == List[2, 3, 4]]

f = \. err['An error happened!']
# f[]

print['*** All tests pass! ***']
