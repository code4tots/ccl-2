# corelib.ccl
#
# A lot of the basic utilities can be implemented in the language itself.
# This should make porting easier if I choose to do so in the future.
#

"""

# Assumed bultins

Nil@__eq__
Nil@str
Nil@repr

Bool@__eq__
Bool@str
Bool@repr

Num+ (unary)
Num- (unary)
Num+
Num-
Num*
Num/
Num%
Num@__eq__
Num@str
Num@repr

Str+
Str% # string format like in Python.
Str@__eq__
Str@str
Str@repr

List@len
List@add
List@pop
List@__eq__
List@str
List@repr
List[]
List[]=

Map@len
Map@__eq__
Map@str
Map@repr
Map[]
Map[]=
Map@keys
Map@vals

Func[]
Func@apply
Func@__eq__
Func@str
Func@repr

"""

List@map = \f {
  i = 0
  xs = L[]
  while i < self.len[] {
    xs.add[f[self[i]]]
    i = i + 1
  }
  return xs
}

List@filter = \f {
  i = 0
  xs = L[]
  while i < self.len[] {
    if f[self[i]]
      xs.add[self[i]]
    i = i + 1
  }
  return xs
}

List@foldl = \f acc {
  i = 0
  while i < self.len[] {
    acc = f[acc, self[i]]
    i = i + 1
  }
  return acc
}

List@foldr = \f acc {
  i = self.len[] - 1
  while 0 <= i {
    acc = f[self[i], acc]
    i = i - 1
  }
  return acc
}

List@fold = List@foldl

List@cut = \start end {
  if end is nil
    end = self.len[]

  if start < 0
    start = start + self.len[]

  if end < 0
    end = end + self.len[]

  if start < 0 or start > self.len[] or end < 0 or end > self.len[]
    err["List@cut range out of bounds: len = " + self.len[].str[] +
        " start = " + start.str[] + " end = " + end.str[]]

  xs = L[]
  i = start
  while i < end {
    xs.add[self[i]]
    i = i + 1
  }

  return xs
}
