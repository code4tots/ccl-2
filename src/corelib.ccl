# corelib.ccl
#
# A lot of the basic utilities can be implemented in the language itself.
# This should make porting easier if I choose to do so in the future.
#

"""

# Bultins implemented natively

Nil@__eq__
Nil@__repr__

Bool@__eq__
Bool@__repr__

Num@__pos__
Num@__neg__
Num@__add__
Num@__sub__
Num@__mul__
Num@__div__
Num@__mod__
Num@__eq__
Num@__repr__

Str@__add__
Str@__mod__ # string format like in Python.
Str@__eq__
Str@__repr__
Str@len
Str[]
Str[]=

List@add
List@pop
List@__eq__
List@__repr__
List@len
List[]
List[]=
List@iter

Map@__eq__
Map@__repr__
Map@len
Map[]
Map[]=
Map@keys
Map@vals
Map@iter

Func[]
Func@apply
Func@__eq__
Func@__repr__

Iter@more
Iter@next

"""

print[1]

Meta@__call__ = \*args. self@__new__[*args]

Val@__ne__ = \r. not (self == r)
Val@__le__ = \r. self < r or self == r
Val@__ge__ = \r. not (self < r)
Val@__gt__ = \r. not (self < r or self == r)
Val@__str__ = \. self.__repr__[]
Val@str = \. self.__str__[]
Val@repr = \. self.__repr__[]

Num@__pos__ = \. self
Num@__neg__ = \. 0 - self

Str@__str__ = \. self

List@map = \f {
  i = 0
  xs = L[]
  while i < self.len[] {
    xs.add[f[self[i]]]
    i = i + 1
  }
  return xs
}

List@filter = \f {
  i = 0
  xs = L[]
  while i < self.len[] {
    if f[self[i]]
      xs.add[self[i]]
    i = i + 1
  }
  return xs
}

List@foldl = \f acc {
  i = 0
  while i < self.len[] {
    acc = f[acc, self[i]]
    i = i + 1
  }
  return acc
}

List@foldr = \f acc {
  i = self.len[] - 1
  while 0 <= i {
    acc = f[self[i], acc]
    i = i - 1
  }
  return acc
}

List@fold = List@foldl

List@cut = \start end {
  if end is nil
    end = self.len[]

  if start < 0
    start = start + self.len[]

  if end < 0
    end = end + self.len[]

  if start < 0 or start > self.len[] or end < 0 or end > self.len[]
    err["List@cut range out of bounds: len = " + self.len[].str[] +
        " start = " + start.str[] + " end = " + end.str[]]

  xs = L[]
  i = start
  while i < end {
    xs.add[self[i]]
    i = i + 1
  }

  return xs
}

List@reduce = \f. self.cut[1, nil].fold[f, self[0]]

# Blobs treat its 'more' and 'next' attributes like methods.
Iter@__new__ = \more next {
  self = new[Iter]
  self@more = more
  self@next = next
  return self
}

Iter@do = \f {
  while self.more[]
    f[self.next[]]
}

Iter@map = \f {
  src = self
  return Iter[
    src.more,
    \. f[src.next[]]
  ]
}

Iter@list = \. {
  xs = L[]
  while self.more[]
    xs.add[self.next[]]
  return xs
}

Iter@__repr__ = \. {
  return "<Iter>"
}

Meta.extend[Val]
Nil.extend[Val]
Bool.extend[Val]
Num.extend[Val]
Str.extend[Val]
List.extend[Val]
Map.extend[Val]
Func.extend[Val]
Iter.extend[Val]
