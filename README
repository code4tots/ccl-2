Sanity (CCL - Cackle)
=====================

Simple programming language with an object model a lot like Lua's.

Usage: ./run.sh <path_to_ccl_script>


Goals
-----

  * Easy to implement and port to new platforms. This is accomplished by:
    * using a very easy to parse syntax.
    * very simple and flexible object model.
    * pushing a lot of functionality into core libraries written in CCL.

  * Easy desktop gui for
    * making simple games
    * making simple utilities
    * designing a text editor

  * Easy mobile gui (android/iOS) for
    * making simple games really quick
    * making simple apps and bodges

    * could probably port to iOS using Google's j2objc or something.

  * Eventually, make the implementation fast enough for contests.


TODO
----

  * Implement some sort of speed performance profiling.
    * At function level -- so CCL users can see which
      functions they wrote that are taking up a lot of time
    * At 'Ast' level -- so I can get a better sense of
      what is slow and what I might be able to speed up.

    * These performance profiling probably don't have to be
      too sophisticated. Just simple timing at entrance
      and exit for function level should be good enough.
      This is going to be a bit weird for functions that
      recurse, but I think for the most part the data
      will still be useful.


Directory layout
----------------

TODO: Elaborate here.

src/
  Where all the Java code for the interpreter is.

cls/
  Generated Java class files.

mods/
  Sanity library modules.

misc/
  Miscellaneous things that aren't actually part of running CCL programs.

  experiments/
    Various things I've experimented with that aren't necessarily included in
    the language proper.

  fbhc/
    Solve facebook hackercup problems to test performance and language
    usability.


Design
------

Just a simple map so that if I decide to burn some of the code, it's going to be easier for me to do some codereuse.

Tier N can compile with only the classes from Tier 1 ... N as dependencies.

Each tier has a designated initializer. This is where all the 'static' blocks and other initialization should be triggered. This way, you can be sure that initializing just the designated class in each tier triggers all the necessary initializations of all the classes in the tier itself and all the tiers before it.

Tier 1 (grammar dir -- Lexer)
  Lexer
  Token
  SyntaxError

Tier 2 (grammar dir -- Parser)
  Parser
  Ast
  AstVisitor

Tier 3 (val dir and eval dir -- Object model and Evaluation)
  val
    Val
    Func
    UserFunc
    BuiltinFunc
    Num
    Str
    List
    Map
  eval
    Err
    Traceable
    Evaluator
    Scope      ** Designated initializer.

  # In terms of filling up the global scope, all of it
  # should be initialized inside 'Scope', since I'm afraid that if
  # I fragment the initialization code into each of the classes,
  # a lot of it might not run properly since instantiating 'Scope'
  # does not necessarily mean that all of the 'Val' subclasses
  # will be initialized.
  #
  # If you require that all initial modifications to GLOBAL
  # be done inside of Scope, you know that GLOBAL will have
  # everything it needs once an instance of Scope is initialized.
  #
  # If you need to add more to your global scope, consider using a proxy
  # global scope (e.g. See Desktop.DESKTOP_GLOBAL).

Tier 4 (Desktop API)
  Desktop      ** Designated initializer
  Gui
  Window
