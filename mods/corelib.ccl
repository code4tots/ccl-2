r"""corelib.ccl

A lot of the basic utilities can be implemented in the language itself.
This should make porting easier if I choose to do so in the future.

# TODO: Make builtin 'Map' operations optional, implemented using List
# so programs can still function even if the underlying environment
# does not have a native 'Map' implementation.

# TODO: Backup 'Regex' implementation for when native environment doesn't
# support regular expressions.

# Bultins implemented natively

# Truthiness cannot be overriden.
# 'nil' and 'false' are false, and all
# other values are true.

L
  # Creates a 'List' instance of its arguments.

M
  # Expects an even number of arguments.
  # Creates a 'Map' instance.

err
  # Expects a single string argument and throws an err.

Val@__meta__
  # expects a single string argument
  # and returns an unbound value from the meta blob's attribute table,
  # or nil if none is found.

Num@__add__
Num@__sub__
Num@__mul__
Num@__div__
Num@__mod__
Num@__eq__
Num@__lt__
Num@repr

Str@__add__
Str@__mod__ # string format like in Python.
Str@__eq__
Str@__lt__
Str@repr
Str@len
Str@__call__ # getitem
Str@int

List@add
List@pop
List@__eq__
List@repr
List@len
List@__call__ # getitem
List@__setitem__
List@iter

Map@__eq__
Map@repr
Map@len
Map@__call__
Map@__setitem__
Map@iter
Map@has
Map@rm

Func@__call__
Func@apply
Func@repr

# TODO: implement this
Regex@match[initial_string, \start, \end]
  # Expects a string to match and optionally an index to start
  # matching at.
  # Returns a MatchData instance or nil if no match was found.

# TODO: MatchData
# TODO: Maybe think of better abstractions. I really like
# Java's solution of having 'Pattern', 'Matcher' and 'MatchResult'.
# I think I like it better than what Ruby does with MatchData
# that I'm copying here. Think about this.

Regex@str
  # Returns the pattern string used to define this regex.

Regex@repl[initial_string, replacement_string, \start, \end]
  # Returns a string where all matching substring of initial_string
  # is replaced by replacement_string.

Regex@find[initial_string, \start, \end]
  # Looks for a match in the range start...end of initial_string,
  # and returns a list of groups on the first match that is found.
  # Returns nil if no match is found.

"""

GLOBAL@assert = \cond /msg. if not cond err[msg or "assertion failed"]
GLOBAL@R = \arg. arg.repr[]
GLOBAL@S = \arg. arg.str[]

GLOBAL@re = \pattern. Regex[pattern]

GLOBAL@max = \*args.
  args.reduce[\a b. if a > b then a else b]

GLOBAL@min = \*args.
  args.reduce[\a b. if a < b then a else b]

Meta@__call__ = \*args. self@__new__[*args]
Meta@__new__ = \name. {
  meta = new[Meta]
  meta@name = name
  return meta
}

Val@repr = \.
  '<' + (self.__meta__['name'] or 'unknown') + ' instance>'
Val@__eq__ = \r. self is r
Val@__ne__ = \r. not (self == r)
Val@__le__ = \r. self < r or self == r
Val@__ge__ = \r. not (self < r)
Val@__gt__ = \r. not (self < r or self == r)
Val@str = \. self.repr[]

Nil@repr = \. 'nil'

Bool@repr = \. if self then 'true' else 'false'

Num@__pos__ = \. self
Num@__neg__ = \. 0 - self

Str@str = \. self

# TODO: Backup implementation of Str@split

Str@words = \. self.split[r'\s+']
Str@lines = \. self.split[r'\n+']

Str@iter = \ {
  i = 0

  return Iter[
    \\. i < self.len[],
    \\. {
      c = self[i]
      i = i + 1
      return c
    }
  ]
}

List@map = \f {
  i = 0
  xs = L[]
  while i < self.len[] {
    xs.add[f[self[i]]]
    i = i + 1
  }
  return xs
}

List@filter = \f {
  i = 0
  xs = L[]
  while i < self.len[] {
    if f[self[i]]
      xs.add[self[i]]
    i = i + 1
  }
  return xs
}

List@foldl = \f acc {
  i = 0
  while i < self.len[] {
    acc = f[acc, self[i]]
    i = i + 1
  }
  return acc
}

List@foldr = \f acc {
  i = self.len[] - 1
  while 0 <= i {
    acc = f[self[i], acc]
    i = i - 1
  }
  return acc
}

List@fold = List@foldl

List@cut = \start end {
  end = end or self.len[]

  if start < 0
    start = start + self.len[]

  if end < 0
    end = end + self.len[]

  if start < 0 or start > self.len[] or end < 0 or end > self.len[]
    err["List@cut range out of bounds: len = " + self.len[].str[] +
        " start = " + start.str[] + " end = " + end.str[]]

  xs = L[]
  i = start
  while i < end {
    xs.add[self[i]]
    i = i + 1
  }

  return xs
}

List@reduce = \f. self.cut[1, nil].fold[f, self[0]]

GLOBAL@Iter = Meta['Iter']

Iter@__new__ = \more next {
  self = new[Iter]
  self@more = more
  self@next = next
  return self
}

# 'more' and 'next' are the core methods of Iter.
# Subclasses will probably want to override just these methods.
Iter@more = \. self@more.apply[self, L[]]
Iter@next = \. self@next.apply[self, L[]]

Iter@iter = \. self

# TODO: Come up with a more elegant way to implement user
# defined iterators. This might mean implementing something
# like generators in Python.
# If I am going to go the generator route, that is going to be
# bit of effort, and if not done carefully, could really
# complicate things.
# I'm pretty happy with the level of cleanliness in 'Evaluator.java'.
# The main issue with generators is that I need to be able to suspend
# evaluation to come back to on a 'yield'.
# I don't want to implement generators until I have a clean elegant way
# of implementing the evaluator.
# work.
Iter@map = \f {
  return Iter[
    \\. self.more[],
    \\. f[self.next[]]
  ]
}

Iter@splat = \f.
  self.map[\item. f[*item]]

# Yea it's unfortunate. Having generators could really make the
# following a lot more elegant.
Iter@filter = \f {
  more = true
  cur = nil

  next = \\. {

    last = cur
    more = false
    while self.more[] {
      x = self.next[]
      if f[x] {
        cur = x
        more = true
        break
      }
    }

    return last
  }

  next[]

  return Iter[\\. more, next]
}

Iter@takeWhile = \f {
  more = true
  cur = nil

  next = \\. {
    last = cur
    x = self.next[]

    if not f[x]
      more = false
    else
      cur = x

    return last
  }

  next[]

  return Iter[\\.more, next]
}

Iter@drop = \n {
  range[0, n].do[\\_.self.next[]]
  return self
}

Iter@dropWhile = \f {
  more = true
  cur = nil

  next = \\. {
    last = cur
    if self.more[]
      cur = self.next[]
    else
      more = false
    return last
  }

  found = false

  while not found and self.more[] {
    cur = self.next[]
    if not f[cur]
      found = true
  }

  if not found
    more = false

  return Iter[\\.more, next]
}

# TODO:
# There seems to be a lot of boilerplate here
# when instantiating Iter...
# Think of an elegant solution that gets rid of
# all this boilerplate without being ugly.
Iter@zip = \iter {
  more = true
  cur = nil

  next = \\. {
    last = cur

    if self.more[] and iter.more[]
      cur = L[self.next[], iter.next[]]
    else
      more = false

    return last
  }

  next[]

  return Iter[\\.more, next]
}

Iter@enum = \. self.zip[range[0]]

Iter@take = \n.
  self.enum[].takeWhile[\xi. xi[1] < n].map[\xi. xi[0]]

Iter@do = \/f {
  f = f or \x.x
  while self.more[]
    f[self.next[]]
}

Iter@list = \. {
  xs = L[]
  while self.more[]
    xs.add[self.next[]]
  return xs
}

GLOBAL@range = \start /end /step. {
  i = start

  step = step or 1

  if step == 0
    err['range step may not be zero']

  more =
    if end is nil      \. true
    else if step > 0   \. i < end
    else               \. i > end

  next = \\{
    val = i
    i = val + step
    return val
  }

  return Iter[more, next]
}

Regex@repr = \. 're[' + self.str[] + ']'
Regex@hash = \. self.str[].hash[]

Meta.extend[Val]
Nil.extend[Val]
Bool.extend[Val]
Num.extend[Val]
Str.extend[Val]
List.extend[Val]
Map.extend[Val]
Func.extend[Val]
Iter.extend[Val]
BuiltinIter.extend[Iter]
Regex.extend[Val]
